[{"id":"1","title":"// architecture overview //","content":"// architecture overview // how works under the hood. // the big picture // nix2gpu transforms declarative nix configurations into reproducible GPU containers through a multi-stage build process. // build pipeline // 1. nix evaluation The nix module system processes your configuration, applying defaults, validating options, and computing the final container specification. 2. dependency resolution Nix builds the entire dependency graph: Base system packages (bash, coreutils, etc.) CUDA toolkit and drivers Your application packages Service configurations Startup scripts 3. image assembly Nimi builds the OCI image (via ) with: Layered filesystem for efficient caching Only necessary dependencies included Reproducible layer ordering 4. container execution The startup script orchestrates initialization, then Nimi runs services. // filesystem layout // Key principles: Immutable system : contains all software, never modified at runtime Mutable state : , , for runtime data Secrets : mounted at from external sources Library paths : dynamic loader configured for both nix store and host-mounted drivers // startup sequence // The container initialization follows a precise sequence: 1. environment setup Sets up PATH for nix store binaries Configures library search for both nix store and host-mounted NVIDIA drivers Establishes CUDA environment 2. runtime detection Adapts configuration based on detected cloud provider or bare-metal environment. 3. GPU initialization Ensures GPU toolchain works with both nix store CUDA and host-mounted drivers. 4. network setup Starts networking services: Tailscale for mesh networking, SSH for remote access. 5. service orchestration Nimi runs the startup hook and then launches your modular services. // service management // Nimi uses Nimi , a tiny process manager for NixOS modular services (Nix 25.11): Benefits over systemd: No init system complexity Modular service definitions JSON config generated by Nix Predictable restart behavior service lifecycle Dependency resolution : services start in correct order Health monitoring : automatic restart on failure Log aggregation : all service logs to stdout for Graceful shutdown : proper signal handling for container stops // networking architecture // standard mode (docker/podman) Standard container networking with port forwarding. tailscale mode (mesh networking) Direct container-to-container communication across hosts via Tailscale. Key advantages: No port forwarding needed Works across clouds and networks End-to-end encryption DNS-based service discovery ACL-based access control // GPU integration // driver compatibility The challenge : CUDA applications need both: CUDA toolkit (development headers, nvcc compiler) from nix store Actual GPU drivers from the host system The solution : dynamic library path configuration This allows nix store CUDA to find host-mounted drivers at runtime. cloud provider adaptations vast.ai : NVIDIA drivers mounted at runpod : Standard nvidia-docker integration bare-metal : Host nvidia-docker setup // secret management // security principles Secrets never enter nix store (nix store is world-readable) Runtime-only access (secrets mounted at container start) File-based injection (not environment variables) Minimal exposure (secrets only accessible to specific processes) agenix integration Flow: Host system decrypts secrets to Container mounts as volume Container references secrets by path, never by value // caching & performance // layer optimization Frequently changing components go in higher layers to maximize cache hits. build caching Nix's content-addressed store ensures perfect reproducibility with efficient incremental builds. registry layer sharing OCI registries deduplicate shared layers across images. // extending the system // custom services custom cloud targets The modular architecture makes it straightforward to add new cloud providers or service types.","path":"architecture.html","tokens":["defaults","works","oci","entire","multi-stage","contains","detected","proper","new","solution","gpu","overview","uses","access","via","advantages","docker","higher","mesh","filesystem","signal","need","execution","software","never","handling","dynamic","host-mounted","frequently","reproducible","nix2gpu","key","adapts","binaries","shared","actual","establishes","module","external","providers","ordering","validating","computing","setup","logs","volume","precise","lifecycle","runtime","nix","coreutils","into","paths","headers","monitoring","standard","graph","toolkit","enter","search","this","mounts","cache","hosts","image","port","library","incremental","hits","accessible","build","podman","dependencies","networks","agenix","find","final","sequence","injection","included","both","tailscale","manager","communication","vast","nvidia-docker","clouds","state","secrets","options","layer","through","container","mutable","decrypts","transforms","orchestrates","sharing","packages","changing","runpod","adaptations","toolchain","maximize","configured","mode","launches","startup","end-to-end","containers","initialization","needed","management","targets","encryption","builds","graceful","host","dependency","your","with","systemd","compatibility","applying","container-to-container","pipeline","shutdown","how","tiny","predictable","optimization","stdout","stops","then","applications","deduplicate","processes","config","discovery","acl-based","networking","straightforward","sources","the","assembly","all","sets","immutable","correct","store","hook","registries","necessary","evaluation","components","content-addressed","generated","custom","modified","for","environment","detection","base","ensures","nixos","architecture","across","control","declarative","variables","registry","configuration","application","runtime-only","path","add","aggregation","from","flow","direct","hood","process","runs","over","efficient","dns-based","orchestration","failure","network","remote","layered","bare-metal","follows","ssh","definitions","starts","exposure","layout","service","performance","makes","configurations","resolution","world-readable","system","development","caching","minimal","specific","integration","value","and","cuda","reproducibility","scripts","provider","bash","log","big","services","order","loader","allows","automatic","principles","data","under","etc","images","based","nvcc","compiler","driver","benefits","extending","nvidia","modular","secret","perfect","configures","restart","not","behavior","complexity","script","layers","challenge","json","health","types","specification","init","security","drivers","file-based","mounted","cloud","start","forwarding","nimi","picture","only","references"],"title_tokens":["architecture","overview"],"anchors":[{"text":"// architecture overview //","id":"architecture-overview","level":1,"tokens":["architecture","overview"]},{"text":"// the big picture //","id":"the-big-picture","level":2,"tokens":["big","picture","the"]},{"text":"// build pipeline //","id":"build-pipeline","level":2,"tokens":["pipeline","build"]},{"text":"1. nix evaluation","id":"1--nix-evaluation","level":3,"tokens":["evaluation","nix"]},{"text":"2. dependency resolution","id":"2--dependency-resolution","level":3,"tokens":["resolution","dependency"]},{"text":"3. image assembly","id":"3--image-assembly","level":3,"tokens":["assembly","image"]},{"text":"4. container execution","id":"4--container-execution","level":3,"tokens":["container","execution"]},{"text":"// filesystem layout //","id":"filesystem-layout","level":2,"tokens":["filesystem","layout"]},{"text":"// startup sequence //","id":"startup-sequence","level":2,"tokens":["startup","sequence"]},{"text":"1. environment setup","id":"1--environment-setup","level":3,"tokens":["environment","setup"]},{"text":"2. runtime detection","id":"2--runtime-detection","level":3,"tokens":["runtime","detection"]},{"text":"3. GPU initialization","id":"3--gpu-initialization","level":3,"tokens":["gpu","initialization"]},{"text":"4. network setup","id":"4--network-setup","level":3,"tokens":["network","setup"]},{"text":"5. service orchestration","id":"5--service-orchestration","level":3,"tokens":["service","orchestration"]},{"text":"// service management //","id":"service-management","level":2,"tokens":["management","service"]},{"text":"Nimi","id":"nimi","level":3,"tokens":["nimi"]},{"text":"service lifecycle","id":"service-lifecycle","level":3,"tokens":["lifecycle","service"]},{"text":"// networking architecture //","id":"networking-architecture","level":2,"tokens":["networking","architecture"]},{"text":"standard mode (docker/podman)","id":"standard-mode--docker-podman","level":3,"tokens":["standard","mode","podman","docker"]},{"text":"tailscale mode (mesh networking)","id":"tailscale-mode--mesh-networking","level":3,"tokens":["tailscale","mesh","networking","mode"]},{"text":"// GPU integration //","id":"gpu-integration","level":2,"tokens":["gpu","integration"]},{"text":"driver compatibility","id":"driver-compatibility","level":3,"tokens":["driver","compatibility"]},{"text":"cloud provider adaptations","id":"cloud-provider-adaptations","level":3,"tokens":["provider","cloud","adaptations"]},{"text":"// secret management //","id":"secret-management","level":2,"tokens":["secret","management"]},{"text":"security principles","id":"security-principles","level":3,"tokens":["security","principles"]},{"text":"agenix integration","id":"agenix-integration","level":3,"tokens":["agenix","integration"]},{"text":"// caching & performance //","id":"caching---performance","level":2,"tokens":["performance","caching"]},{"text":"layer optimization","id":"layer-optimization","level":3,"tokens":["layer","optimization"]},{"text":"build caching","id":"build-caching","level":3,"tokens":["build","caching"]},{"text":"registry layer sharing","id":"registry-layer-sharing","level":3,"tokens":["sharing","registry","layer"]},{"text":"// extending the system //","id":"extending-the-system","level":2,"tokens":["system","extending","the"]},{"text":"custom services","id":"custom-services","level":3,"tokens":["custom","services"]},{"text":"custom cloud targets","id":"custom-cloud-targets","level":3,"tokens":["targets","cloud","custom"]}]},{"id":"2","title":"// index //","content":"// index // declarative GPU containers. vast.ai. runpod. bare-metal. zero dockerfile cope. // start here // getting started â€” build your first container, ssh in options reference â€” all the knobs architecture â€” how it works internally services & runtime â€” Nimi, startup sequence defining custom services â€” add your own service modules secrets & agenix â€” keys never touch the nix store integrations â€” integrations with the nix ecosystem // high-level // declare containers under each container config is a nix module (like nixos modules) assembles: root filesystem with nix store + your packages startup script for runtime environment service graph via Nimi helper commands: â€” build image â€” load into docker/podman â€” push to ghcr â€” push to runpod // cloud targets // platform status notes vast.ai âœ… stable nvidia libs at runpod âœ… stable network volumes, template support lambda labs âœ… works standard docker bare-metal âœ… works just run the container kubernetes ðŸš§ wip gpu operator integration // where to go // just want something running â†’ getting started want all the options â†’ options reference hacking on internals â†’ architecture secrets and tailscale â†’ secrets","path":"index.html","tokens":["bare-metal","how","docker","build","works","never","helper","first","architecture","cope","ssh","like","integrations","graph","ghcr","ecosystem","service","status","support","gpu","packages","cloud","declarative","want","module","labs","startup","standard","kubernetes","and","tailscale","hacking","index","sequence","services","targets","under","all","high-level","with","runtime","config","load","for","podman","platform","network","volumes","operator","script","where","the","nixos","wip","something","custom","touch","image","modules","via","own","commands","into","reference","notes","containers","zero","lambda","runpod","assembles","dockerfile","just","stable","internals","agenix","filesystem","internally","secrets","your","nix","template","vast","nimi","run","knobs","environment","options","running","declare","libs","getting","started","container","store","nvidia","keys","add","push","defining","here","each","integration","root","start"],"title_tokens":["index"],"anchors":[{"text":"// index //","id":"index","level":1,"tokens":["index"]},{"text":"// start here //","id":"start-here","level":2,"tokens":["here","start"]},{"text":"// high-level //","id":"high-level","level":2,"tokens":["high-level"]},{"text":"// cloud targets //","id":"cloud-targets","level":2,"tokens":["targets","cloud"]},{"text":"// where to go //","id":"where-to-go","level":2,"tokens":["where"]}]},{"id":"3","title":"// defining a custom service //","content":"// defining a custom service // Use NixOS modular services (Nix 25.11) to describe long-running processes. runs them through , so there is no extra flake input to enable. // example: a simple HTTP server // This example defines a tiny service module that runs . // using existing modular services // If a package ships a modular service module, you can import it directly. For example, from : Need a fuller reference? See for a real-world service module.","path":"custom-service.html","tokens":["module","long-running","nix","existing","enable","using","package","services","this","import","custom","service","server","directly","processes","from","real-world","that","describe","see","for","modular","input","you","defining","fuller","simple","nixos","tiny","http","can","example","reference","use","defines","need","runs","through","them","flake","extra","ships","there"],"title_tokens":["service","custom","defining"],"anchors":[{"text":"// defining a custom service //","id":"defining-a-custom-service","level":1,"tokens":["custom","defining","service"]},{"text":"// example: a simple HTTP server //","id":"example--a-simple-http-server","level":1,"tokens":["server","example","http","simple"]},{"text":"simple-http.nix","id":"simple-http-nix","level":3,"tokens":["nix","simple-http"]},{"text":"server.nix","id":"server-nix","level":3,"tokens":["nix","server"]},{"text":"// using existing modular services //","id":"using-existing-modular-services","level":1,"tokens":["using","modular","existing","services"]}]},{"id":"4","title":"// services & runtime //","content":"// services & runtime // managing long-running processes inside containers. // overview // uses , a tiny process manager for NixOS modular services (Nix 25.11). Define services under and will build an OCI image with Nimi as the entrypoint. No extra flake inputs are required to enable services. // defining services // using existing modular services a minimal custom service For a full custom module example, see defining custom services . // runtime behavior // When the container starts, Nimi runs the startup hook and then launches all configured services. You can still drop into a shell for debugging with: // restart policies // controls service restarts. Tune it with : // logging // Logs always stream to stdout/stderr for . You can also enable per-service log files: At runtime, Nimi creates a directory under and writes one file per service. // config data // Modular services can provide config files via . Nimi exposes these files under a temporary directory and sets for the service. This lets services read configs from without writing to the Nix store. See service modules like for real-world usage.","path":"services.html","tokens":["per","long-running","read","per-service","behavior","provide","modules","also","writes","directory","store","drop","nix","always","required","then","policies","you","will","logs","stream","log","debugging","runtime","full","existing","starts","shell","hook","the","when","extra","one","under","tune","temporary","with","sets","module","configs","service","stderr","from","writing","real-world","without","are","processes","image","container","exposes","stdout","oci","enable","defining","and","inside","logging","controls","managing","restart","see","files","flake","into","usage","process","file","manager","configured","nixos","build","minimal","restarts","config","can","startup","entrypoint","creates","like","data","runs","these","example","nimi","still","services","launches","custom","for","uses","tiny","using","all","inputs","containers","overview","via","this","lets","define","modular"],"title_tokens":["runtime","services"],"anchors":[{"text":"// services & runtime //","id":"services---runtime","level":1,"tokens":["runtime","services"]},{"text":"// overview //","id":"overview","level":2,"tokens":["overview"]},{"text":"// defining services //","id":"defining-services","level":2,"tokens":["defining","services"]},{"text":"using existing modular services","id":"using-existing-modular-services","level":3,"tokens":["services","modular","existing","using"]},{"text":"a minimal custom service","id":"a-minimal-custom-service","level":3,"tokens":["service","minimal","custom"]},{"text":"// runtime behavior //","id":"runtime-behavior","level":2,"tokens":["runtime","behavior"]},{"text":"// restart policies //","id":"restart-policies","level":2,"tokens":["restart","policies"]},{"text":"// logging //","id":"logging","level":2,"tokens":["logging"]},{"text":"// config data //","id":"config-data","level":2,"tokens":["data","config"]}]},{"id":"5","title":"// ComfyUI setup guide //","content":"// setup guide // This guide covers a walk through of setting up inside a container, and then deploying it to . It should hopefully also provide useful information to others trying to deploy different pieces of software too. Installing Nix First of all, you'll need to install Nix . There are a couple of easy ways to get it: The Determinate Nix Installer (Mac, Linux) NixOS WSL (Windows subsystem for Linux) Creating a flake to develop out of: With nix installed you can now run: Adding Inputs You will now have a new git repository with an empty . Edit this to add Into the section. No additional inputs are required to use services or ; bundles and internally. Replace the outputs section with this: Select a starter config to use Take a look in the examples folder and pick one which looks useful. Going forward, we will use the example. We can run this in like (replacing the from earlier: Getting the instance onto vast You can now build and copy your service to the GitHub package registry (ghcr.io) with Next, go to the vast.ai web UI and create a new template, using the GitHub package we just pushed as the source when prompted. Now, reserve a new instance on vast using the template and give it a few minutes to start up (wait for \"Running...\"). Now, use the web UI to add an ssh key. You can get/find your public key with this guide . Once you have it, use the key shaped button on your running vast instance and paste the key starting with or into the keys for the instance. You can now connect with the command and IP address it gives you. Make sure you use to be able to view comfy UI in your browser. Other options You can also run a image locally if you have docker or installed:","path":"getting-started.html","tokens":["pick","ways","key","use","going","make","installing","empty","mac","hopefully","container","nix","need","the","source","windows","look","git","pushed","paste","docker","once","this","services","information","instance","template","through","determinate","shaped","command","for","start","one","all","getting","other","setting","running","when","comfy","ghcr","using","inside","your","keys","setup","ssh","like","replacing","locally","example","different","outputs","nixos","options","github","address","develop","take","repository","into","inputs","get","wsl","create","edit","bundles","will","covers","should","others","starter","add","forward","registry","examples","service","prompted","with","web","section","minutes","replace","couple","pieces","additional","have","easy","linux","you","flake","folder","install","and","too","select","which","provide","next","looks","build","just","reserve","button","useful","view","image","trying","package","subsystem","installer","copy","find","there","are","can","creating","able","walk","new","then","few","vast","run","software","now","adding","internally","required","from","connect","give","deploying","first","out","guide","public","sure","config","also","starting","onto","gives","installed","earlier","wait","browser","deploy"],"title_tokens":["setup","guide","comfyui"],"anchors":[{"text":"// ComfyUI setup guide //","id":"comfyui-setup-guide","level":1,"tokens":["comfyui","setup","guide"]},{"text":"Installing Nix","id":"installing-nix","level":1,"tokens":["nix","installing"]},{"text":"Creating a flake to develop out of:","id":"creating-a-flake-to-develop-out-of","level":1,"tokens":["creating","out","develop","flake"]},{"text":"Adding Inputs","id":"adding-inputs","level":1,"tokens":["adding","inputs"]},{"text":"Replace the outputs section with this:","id":"replace-the-outputs-section-with-this","level":1,"tokens":["outputs","replace","section","with","this","the"]},{"text":"Select a nix2gpu starter config to use","id":"select-a-nix2gpu-starter-config-to-use","level":1,"tokens":["select","use","nix2gpu","starter","config"]},{"text":"Getting the ComfyUI instance onto vast","id":"getting-the-comfyui-instance-onto-vast","level":1,"tokens":["comfyui","instance","onto","the","vast","getting"]},{"text":"Other options","id":"other-options","level":1,"tokens":["other","options"]}]},{"id":"6","title":"// integrations //","content":"// integrations // ships its integrations as part of the flake. You do not enable them by adding extra inputs upstream; if you are using the flake, they are already available. // (modular services) // is the runtime that powers services in . It runs NixOS modular services (Nix 25.11) without requiring a full init system. Define services under using modular service modules. Tune runtime behavior with (restart, logging, startup). See services & runtime for the workflow and examples. // // builds OCI images through 's , which uses under the hood. You do not need to add a separate input to use containers. // // is integrated for user environment configuration. Use the option to describe shell configuration, tools, and dotfiles in a modular way. If you are porting an existing home-manager config that targets a non-root user, includes a convenience module: See the home option for details.","path":"integrations.html","tokens":["configuration","through","flake","images","targets","input","with","already","and","enable","upstream","without","init","tune","separate","them","hood","not","environment","tools","non-root","adding","its","define","describe","dotfiles","you","available","examples","need","ships","that","service","user","way","convenience","builds","they","home-manager","inputs","details","shell","nixos","use","option","services","using","see","integrated","under","extra","module","startup","are","powers","full","system","config","requiring","containers","logging","runs","restart","uses","existing","modular","part","add","porting","behavior","runtime","integrations","workflow","includes","which","nix","the","for","oci","home","modules"],"title_tokens":["integrations"],"anchors":[{"text":"// integrations //","id":"integrations","level":1,"tokens":["integrations"]},{"text":"// Nimi (modular services) //","id":"nimi--modular-services","level":2,"tokens":["modular","services","nimi"]},{"text":"// nix2container //","id":"nix2container","level":2,"tokens":["nix2container"]},{"text":"// home-manager //","id":"home-manager","level":2,"tokens":["home-manager"]}]},{"id":"7","title":"Option: _module.args","content":"Additional arguments passed to each module in addition to ones like , , and , . This option is also available to all submodules. Submodules do not inherit args from their parent module, nor do they provide args to their parent module or sibling submodules. The sole exception to this is the argument which is provided by parent modules to a submodule and contains the attribute name the submodule is bound to, or a unique generated name if it is not bound to an attribute. Some arguments are already passed by default, of which the following cannot be changed with this option: {var} : The nixpkgs library. {var} : The results of all options after merging the values from all modules together. {var} : The options declared in all modules. {var} : The argument passed to . All attributes of {var} Whereas option values can generally depend on other option values thanks to laziness, this does not apply to , which must be computed statically before anything else. For this reason, callers of the module system can provide which are available during import resolution. For NixOS, includes {var} , which allows you to import extra modules from the nixpkgs package tree without having to somehow make the module aware of the location of the or NixOS directories. For NixOS, the default value for this option includes at least this argument: {var} : The nixpkgs package set according to the {option} option.","path":"options.html#option-_module-args","tokens":["statically","else","import","this","allows","argument","extra","somehow","directories","and","also","merging","submodule","submodules","value","already","cannot","for","set","modules","from","parent","each","their","passed","ones","name","attribute","unique","var","must","aware","provide","some","following","without","provided","they","all","computed","depend","reason","option","during","includes","package","tree","values","options","generated","can","you","sole","results","according","library","not","resolution","make","are","system","laziness","the","which","declared","anything","additional","does","after","attributes","bound","like","apply","location","nor","with","other","before","having","least","thanks","addition","exception","whereas","callers","generally","default","nixpkgs","nixos","inherit","arguments","sibling","args","available","module","together","changed","contains"],"title_tokens":["option","args","_module"],"anchors":[]},{"id":"8","title":"Option: age","content":"The configuration for the container's user environment. This module is a port of to , and allows simplified management of age encrypted secrets in nix. To use this, you must first enable the optional integration: Then enable the module with:","path":"options.html#option-age","tokens":["integration","age","the","port","you","allows","configuration","nix","encrypted","first","for","module","simplified","use","must","and","user","environment","this","enable","optional","secrets","management","container","then","with"],"title_tokens":["option","age"],"anchors":[]},{"id":"9","title":"Option: age.enable","content":"Whether to enable enable agenix integration.","path":"options.html#option-age-enable","tokens":["enable","whether","agenix","integration"],"title_tokens":["option","age","enable"],"anchors":[]},{"id":"10","title":"Option: age.identityPaths","content":"Paths to SSH keys to be used as identities in age decryption.","path":"options.html#option-age-identityPaths","tokens":["used","paths","ssh","identities","age","keys","decryption"],"title_tokens":["age","option","identitypaths"],"anchors":[]},{"id":"11","title":"Option: age.package","content":"The rage package to use.","path":"options.html#option-age-package","tokens":["package","rage","use","the"],"title_tokens":["option","age","package"],"anchors":[]},{"id":"12","title":"Option: age.secrets","content":"Attrset of secrets.","path":"options.html#option-age-secrets","tokens":["attrset","secrets"],"title_tokens":["secrets","age","option"],"anchors":[]},{"id":"13","title":"Option: age.secrets.&lt;name&gt;.file","content":"Age file the secret is loaded from.","path":"options.html#option-age-secrets-<name>-file","tokens":["age","file","loaded","from","the","secret"],"title_tokens":["age","option","name","file","secrets"],"anchors":[]},{"id":"14","title":"Option: age.secrets.&lt;name&gt;.mode","content":"Permissions mode of the decrypted secret in a format understood by chmod.","path":"options.html#option-age-secrets-<name>-mode","tokens":["format","permissions","the","decrypted","chmod","understood","mode","secret"],"title_tokens":["option","name","secrets","mode","age"],"anchors":[]},{"id":"15","title":"Option: age.secrets.&lt;name&gt;.name","content":"Name of the file used in ${cfg.secretsDir}","path":"options.html#option-age-secrets-<name>-name","tokens":["the","used","name","secretsdir","cfg","file"],"title_tokens":["option","name","age","secrets"],"anchors":[]},{"id":"16","title":"Option: age.secrets.&lt;name&gt;.path","content":"Path where the decrypted secret is installed.","path":"options.html#option-age-secrets-<name>-path","tokens":["path","installed","decrypted","the","where","secret"],"title_tokens":["secrets","name","age","path","option"],"anchors":[]},{"id":"17","title":"Option: age.secrets.&lt;name&gt;.symlink","content":"Whether to enable symlinking secrets to their destination.","path":"options.html#option-age-secrets-<name>-symlink","tokens":["whether","enable","secrets","destination","their","symlinking"],"title_tokens":["option","secrets","name","symlink","age"],"anchors":[]},{"id":"18","title":"Option: age.secretsDir","content":"Folder where secrets are symlinked to","path":"options.html#option-age-secretsDir","tokens":["are","secrets","where","folder","symlinked"],"title_tokens":["age","option","secretsdir"],"anchors":[]},{"id":"19","title":"Option: age.secretsMountPoint","content":"Where secrets are created before they are symlinked to ${cfg.secretsDir}","path":"options.html#option-age-secretsMountPoint","tokens":["are","before","created","where","symlinked","secretsdir","they","secrets","cfg"],"title_tokens":["option","age","secretsmountpoint"],"anchors":[]},{"id":"20","title":"Option: copyToRoot","content":"A list of packages to be copied to the root of the container. This option allows you to specify a list of Nix packages that will be symlinked into the root directory of the container. This is useful for making essential packages and profiles available at the top level of the container's filesystem. The default value includes the base system, the container's profile, and the Nix store profile, which are essential for the container to function correctly. If you want to add extra packages without replacing the default set, use the option instead. This is a direct mapping to the attribute from .","path":"options.html#option-copyToRoot","tokens":["symlinked","top","list","filesystem","store","are","this","function","correctly","the","direct","option","that","set","specify","directory","nix","includes","root","for","profiles","replacing","copied","use","instead","add","you","allows","base","making","without","mapping","attribute","level","from","into","value","will","useful","default","profile","which","essential","container","available","extra","and","packages","want","system"],"title_tokens":["copytoroot","option"],"anchors":[]},{"id":"21","title":"Option: cudaPackages","content":"The set of CUDA packages to be used in the container. This option allows you to select a specific version of the CUDA toolkit to be installed in the container. This is crucial for ensuring compatibility with applications and machine learning frameworks that depend on a particular CUDA version. The value should be a package set from . You can find available versions by searching for in Nixpkgs .","path":"options.html#option-cudaPackages","tokens":["the","compatibility","package","packages","applications","crucial","searching","used","machine","option","versions","that","installed","with","cuda","should","find","learning","particular","and","container","available","for","select","can","ensuring","nixpkgs","toolkit","allows","set","depend","this","you","specific","version","frameworks","from","value"],"title_tokens":["cudapackages","option"],"anchors":[]},{"id":"22","title":"Option: env","content":"A list of environment variables to set inside the container. This option allows you to define the environment variables that will be available within the container. The default value provides a comprehensive set of environment variables for a typical development environment, including paths for Nix, CUDA, and other essential tools. If you want to add extra environment variables without replacing the default set, use the option instead. This is a direct mapping to the attribute of the oci container spec .","path":"options.html#option-env","tokens":["container","set","replacing","default","available","paths","comprehensive","that","development","environment","for","other","use","inside","you","this","value","typical","mapping","oci","including","direct","attribute","without","tools","add","cuda","define","spec","will","nix","want","instead","allows","variables","option","list","and","extra","provides","within","the","essential"],"title_tokens":["option","env"],"anchors":[]},{"id":"23","title":"Option: exposedPorts","content":"A set of ports to expose from the container. This option allows you to specify which network ports should be exposed by the container. The keys are the port and protocol (e.g., \"80/tcp\"), and the values are empty attribute sets. By default, port 22 is exposed for SSH access. This is a direct mapping to the attribute of the oci container spec .","path":"options.html#option-exposedPorts","tokens":["values","allows","tcp","from","this","you","which","set","direct","default","specify","empty","sets","the","and","expose","option","are","port","exposed","attribute","mapping","ssh","network","protocol","access","oci","keys","for","container","should","spec","ports"],"title_tokens":["option","exposedports"],"anchors":[]},{"id":"24","title":"Option: extraEnv","content":"A list of extra environment variables to set inside the container. This option allows you to add more environment variables to the option without overriding the default set. The variables listed here will be appended to the main list. This is the recommended way to add your own custom environment variables.","path":"options.html#option-extraEnv","tokens":["option","overriding","more","main","variables","you","allows","inside","set","without","container","default","here","this","extra","will","list","the","appended","recommended","way","own","custom","add","your","environment","listed"],"title_tokens":["option","extraenv"],"anchors":[]},{"id":"25","title":"Option: extraLabels","content":"A set of extra labels to apply to the container. This option allows you to add custom metadata to the container in the form of labels. These labels can be used for organizing and filtering containers, or for storing information about the container's contents or purpose. The labels defined here will be merged with the default set. This is the recommended way to add more labels to your project rather than overriding labels.","path":"options.html#option-extraLabels","tokens":["recommended","set","will","organizing","can","apply","about","containers","the","used","here","than","merged","contents","with","rather","container","project","purpose","for","way","you","allows","extra","metadata","option","labels","form","and","filtering","information","default","overriding","more","custom","your","these","storing","add","defined","this"],"title_tokens":["option","extralabels"],"anchors":[]},{"id":"26","title":"Option: extraStartupScript","content":"A string of shell commands to be executed at the end of the container's startup script. This option provides a way to run custom commands every time the container starts. The contents of this option will be appended to the main startup script, after the default startup tasks have been completed. This is useful for tasks such as starting services, running background processes, or printing diagnostic information.","path":"options.html#option-extraStartupScript","tokens":["such","string","provides","run","time","useful","for","starting","the","commands","contents","end","startup","every","running","tasks","background","custom","services","main","information","have","appended","starts","will","after","processes","shell","been","way","script","option","completed","printing","executed","this","container","default","diagnostic"],"title_tokens":["extrastartupscript","option"],"anchors":[]},{"id":"27","title":"Option: home","content":"The configuration for the container's user environment. This option allows you to define the user's home environment using . You can configure everything from shell aliases and environment variables to user services and application settings. By default, a minimal set of useful modern shell packages is included to provide a comfortable and secure hacking environment on your machines. is bundled with , so no additional flake inputs are required to use this option.","path":"options.html#option-home","tokens":["with","from","are","hacking","bundled","minimal","using","use","user","required","aliases","and","provide","option","this","additional","container","define","settings","application","configuration","you","can","allows","everything","shell","included","environment","packages","your","modern","flake","inputs","secure","services","for","variables","useful","set","default","the","home","comfortable","machines","configure"],"title_tokens":["home","option"],"anchors":[]},{"id":"28","title":"Option: labels","content":"A set of labels to apply to the container. This option allows you to define metadata for the container in the form of labels. These labels can be used for organizing and filtering containers, or for storing information about the container's contents or purpose. The default value includes several labels that provide information about the container's origin, runtime, and dependencies. If you want to add extra labels without replacing the default set, use the option instead. This is a direct mapping to the attribute of the oci container spec .","path":"options.html#option-labels","tokens":["contents","value","use","containers","option","for","the","and","that","can","direct","several","default","replacing","attribute","oci","this","organizing","filtering","metadata","storing","provide","mapping","set","origin","runtime","spec","define","used","container","want","instead","apply","information","includes","allows","form","you","labels","about","purpose","add","extra","these","without","dependencies"],"title_tokens":["option","labels"],"anchors":[]},{"id":"29","title":"Option: maxLayers","content":"The maximum number of layers to use when creating the container image. This option sets the upper limit on the number of layers that will be used to build the container image. This is an important consideration for caching and build time purposes, and can have many benefits. See this blog post for some nice information on layers in a nix context. This is a direct mapping to the attribute from .","path":"options.html#option-maxLayers","tokens":["the","number","have","see","blog","post","some","context","used","mapping","upper","will","container","this","layers","limit","benefits","consideration","information","attribute","creating","many","maximum","important","direct","time","nix","when","that","sets","use","for","caching","from","build","and","nice","purposes","option","image","can"],"title_tokens":["maxlayers","option"],"anchors":[]},{"id":"30","title":"Option: meta","content":"attributes to include in the output of generated containers","path":"options.html#option-meta","tokens":["containers","the","include","attributes","output","generated"],"title_tokens":["option","meta"],"anchors":[]},{"id":"31","title":"Option: nimiSettings","content":"Bindings to for this nix2gpu instance. Use this to tune Nimi runtime behavior (restart policy, logging, startup hooks, and container build settings) beyond the defaults provided by nix2gpu.","path":"options.html#option-nimiSettings","tokens":["beyond","provided","nimi","settings","runtime","bindings","logging","nix2gpu","tune","this","behavior","restart","build","use","instance","and","policy","the","for","hooks","startup","container","defaults"],"title_tokens":["nimisettings","option"],"anchors":[]},{"id":"32","title":"Option: nixConfig","content":"The content of the file to be used inside the container. This option allows you to provide a custom configuration for the Nix daemon running inside the container. This can be used to configure things like custom binary caches, experimental features, or other Nix-related settings. By default, a standard is provided which is suitable for most use cases.","path":"options.html#option-nixConfig","tokens":["the","provided","standard","caches","which","provide","this","for","can","use","cases","default","you","most","option","configuration","used","daemon","nix-related","settings","nix","inside","binary","suitable","things","like","content","other","configure","container","custom","allows","experimental","features","running","file"],"title_tokens":["option","nixconfig"],"anchors":[]},{"id":"33","title":"Option: passthru","content":"attributes to include in the output of generated containers","path":"options.html#option-passthru","tokens":["generated","output","containers","attributes","include","the"],"title_tokens":["option","passthru"],"anchors":[]},{"id":"34","title":"Option: registries","content":"The container registries to push your images to. This option specifies a list of the full registry paths, including the repository and image name, where the container image will be pushed. This is a mandatory field if you intend to publish your images via .","path":"options.html#option-registries","tokens":["list","where","pushed","images","full","the","including","container","repository","image","mandatory","publish","will","field","paths","option","specifies","name","intend","you","via","registry","and","this","registries","your","push"],"title_tokens":["option","registries"],"anchors":[]},{"id":"35","title":"Option: services","content":"Services to run inside the container via . Each attribute defines a named NixOS modular service (Nix 25.11): import a service module and override its options per instance. This keeps service definitions composable and reusable across projects. For the upstream model, see the NixOS manual section on Modular Services .","path":"options.html#option-services","tokens":["this","named","section","import","instance","keeps","options","for","projects","services","nix","upstream","service","defines","its","definitions","per","nixos","override","attribute","the","inside","run","across","see","manual","model","container","modular","via","reusable","each","module","composable","and"],"title_tokens":["option","services"],"anchors":[]},{"id":"36","title":"Option: sshdConfig","content":"The content of the file to be used inside the container. This option allows you to provide a custom configuration for the OpenSSH daemon ( ) running inside the container. This can be used to customize security settings, authentication methods, and other SSH-related options. By default, a standard is provided that is suitable for most use cases, with password authentication disabled in favor of public key authentication.","path":"options.html#option-sshdConfig","tokens":["standard","security","disabled","the","provide","public","content","ssh-related","password","custom","with","configuration","option","daemon","you","methods","customize","that","suitable","key","can","authentication","used","file","and","options","provided","settings","use","running","cases","default","allows","favor","this","most","container","openssh","inside","other","for"],"title_tokens":["option","sshdconfig"],"anchors":[]},{"id":"37","title":"Option: systemPackages","content":"A list of system packages to be copied into the container. This option allows you to specify a list of Nix packages that will be added to the container.","path":"options.html#option-systemPackages","tokens":["list","will","packages","copied","the","allows","specify","nix","system","this","that","added","container","you","into","option"],"title_tokens":["systempackages","option"],"anchors":[]},{"id":"38","title":"Option: tag","content":"The tag to use for your container image. This option specifies the tag that will be applied to the container image when it is built and pushed to a registry. Tags are used to version and identify different builds of your image. The default value is \"latest\", which is a common convention for the most recent build. However, it is highly recommended to use more descriptive tags for production images, such as version numbers or git commit hashes.","path":"options.html#option-tag","tokens":["value","git","identify","descriptive","hashes","pushed","option","used","such","will","version","convention","recent","container","different","more","commit","for","tags","build","however","the","highly","specifies","and","use","your","built","default","common","recommended","when","tag","applied","builds","which","are","image","that","latest","numbers","this","registry","most","production","images"],"title_tokens":["option","tag"],"anchors":[]},{"id":"39","title":"Option: tailscale","content":"The tailscale configuration to use for your container. Configure the tailscale daemon to run on your instance, giving your instances easy and secure connectivity.","path":"options.html#option-tailscale","tokens":["daemon","for","configuration","and","configure","connectivity","secure","giving","easy","use","tailscale","the","container","instances","your","instance","run"],"title_tokens":["tailscale","option"],"anchors":[]},{"id":"40","title":"Option: tailscale.authKey","content":"Runtime path to valid tailscale auth key","path":"options.html#option-tailscale-authKey","tokens":["runtime","path","tailscale","auth","key","valid"],"title_tokens":["option","authkey","tailscale"],"anchors":[]},{"id":"41","title":"Option: tailscale.enable","content":"Whether to enable enable the tailscale daemon.","path":"options.html#option-tailscale-enable","tokens":["enable","the","tailscale","whether","daemon"],"title_tokens":["tailscale","option","enable"],"anchors":[]},{"id":"42","title":"Option: user","content":"The default user for the container. This option specifies the username of the user that will be used by default when running commands or starting services in the container. The default value is \"root\". While this is convenient for development, it is strongly recommended to create and use a non-root user for production environments to improve security. You can create users and groups using the and options in your configuration.","path":"options.html#option-user","tokens":["that","create","for","strongly","username","user","running","starting","option","services","value","options","commands","can","and","while","users","environments","default","you","use","development","convenient","improve","recommended","non-root","this","used","specifies","your","when","container","the","groups","production","security","will","root","using","configuration"],"title_tokens":["option","user"],"anchors":[]},{"id":"43","title":"Option: workingDir","content":"The working directory for the container. This option specifies the directory that will be used as the current working directory when the container starts. It is the directory where commands will be executed by default. The default value is \"/root\". You may want to change this to a more appropriate directory for your application, such as or .","path":"options.html#option-workingDir","tokens":["for","current","you","specifies","container","used","value","working","change","that","want","the","such","appropriate","may","default","your","option","this","will","when","where","commands","executed","more","application","starts","root","directory"],"title_tokens":["option","workingdir"],"anchors":[]}]